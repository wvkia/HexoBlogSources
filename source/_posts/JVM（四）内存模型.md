---
title: JVM（四）内存模型
date: 2018-04-17 00:49:36
tags: [JVM]
---
#### JVM内存模型

#####  多任务概述
多任务的好处
1. 充分利用计算机性能
2. 阻塞的存在，例如IO阻塞，存储和计算机的处理速度相差太大，需要多任务来压榨性能
3. 简化问题描述

TPS（Transactions Pre Seconds）：
> 每秒处理的事务数，用来衡量一个服务性能的高低好坏。它代表一秒内服务端平均能响应的请求总数，而TPS和程序的并发能力又有密切的关系。对于计算量相同的任务，如果线程并发有条不紊，则效率就高，TPS就大；如果线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。

##### 物理计算机的并发问题
根据操作系统原理，由于计算机处理速度和存储器的速度远远不匹配，即使和内存相比也是差距很大，为了平衡这种差距，在内存和处理器之间加了一层或几层的高速缓存Cache作为缓冲：将运算需要的数据首先复制到高速缓存，然后处理器读取缓存数据处理，当运算结束，再从处理器同步到高速缓存，最后再同步到内存中。
基于高速缓存的存储交互很好的解决了处理器和内存的速度矛盾，但也带来另一个问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，但它们又共享同一个主内存（Main Memory），这种情况下，如果多个处理器的运算任务同时设计同一个主内存区域，将导致各自的缓存数据不一致，那么在同步回主内存时，就不知道以哪个任务的缓存数据为主？为了解决这个问题，需要各个处理器访问缓存时遵循一些协议，包括MSI，即针对硬件的读写内存协议。而内存模型，就是在特定操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。

	处理器1 <--> 高速缓存 <--> |            |
    处理器2 <--> 高速缓存 <--> |缓存一致性协议 |  <-->主内存
    处理器3 <--> 高速缓存 <--> |            |
    
除了增加高速缓存外，为了使处理器内部运算单元能尽量被利用，处理器还会可能对输入代码进行乱序执行优化（Out-of-Order-Execution），处理器会在计算后对结果重组，保证结果和顺序执行结果一致，但并不保证程序中各个语句计算的先后顺序和输入代码顺序一致，因此，如果一个任务依赖另一个任务的中间结果，那顺序性就不能根据代码的先后顺序来保证。JVM中也有类似的指令重排序（Instruction Reorder）

##### Java内存模型
Java内存模型就是用来屏蔽硬件和操作系统差异，保证让java在各个平台都能达到一致的内存访问效果。JVM中也有类似物理硬件的内存模型，存在主内存和工作内存，主内存是所有线程公有的，每个线程还有自己的工作内存，线程的工作内存保存使用的变量的主内存副本拷贝，线程对变量的所有操作都在工作内存中，线程之间不能直接读取数据，只能通过主内存

	Java线程1 <--> 工作内存 <--> |             |
    Java线程2 <--> 工作内存 <--> |Save和load操作| <--> 主内存
    Java线程3 <--> 工作内存 <--> |             |

###### 工作内存和主内存之间的交互
下面的交互都是原子性的
lock锁定主内存变量，标志为一个线程独占；
unlock解锁主内存变量
read读取主内存变量到工作内存
load载入工作内存变量给副本，供线程使用
use使用工作内存变量
assign赋值工作内存变量
store存储工作内存变量，供随后的write用
write从工作内存写到主内存中

###### volatile变量
当一个变量被定义为volatile时，它将具备两种特性：
1. 保证此变量对所有线程的可见性
> 可见性是指当一条线程修改了这个变量值，新值对其他线程来说是立即可见的
> 普通变量不能保证可见性，因为普通变量需要主内存传递，线程A修改了一个普通变量值，需要向主内存写，然后线程B在A写入完成之后，再进行主内存读取，这时候新变量值才会被B看到。如果在A修改之后还没写入主内存时，时间片被切给B，B从主内存读取的就是过期值。
> 但volatile是怎么保证可见性的呢？在volatile变量被修改赋值后，会多执行一句lock addl操作，这个操作相当于一个内存屏障（Memerory Barrier），作用是使本CPU的cache值立即写入到主内存，该写入操作也会导致其他CPU的内核无效化，需要重新读取主内存。
> 但volatile不能保证原子性。其原因在于CPU高速缓存的存在，例如线程A对volatile变量执行value++操作，而CPU内部对value++通常不是原子性的，而是多步骤操作，例如在volatile被++之后得到新值，保存在高速缓存寄存器中，线程的副本值是新值，还没赋值给volatile变量，即没有触发assign操作，也就没办法触发上述的lock addl操作，那么如果此时时间片被分给另一个线程读取的就还是旧值。

2. 禁止指令重排序
> 普通变量只能保证该方法执行过程中所有依赖结果的地方都是对的，但不能保证变量赋值操作的顺序和程序代码执行一致，而volatile变量可以保证
> 其原因还是上述的内存屏障，即volatile前面的代码肯定是执行完了，其结果对后面的操作结果可见，而后面的操作肯定还没有执行。
> 指令重排序无法越过内存屏障

使用volatile的情景：
1. 运算结果不依赖变量当前值，或者能够保证只有单一线程修改变量值
2. 变量不需要和其他状态共同参与不变约束
只有满足上述要求，才能说volatile是原子可用的，否则必须通过加锁保证原子性

##### 原子性、可见性、有序性
整个内存模型就是围绕着并发过程中如何处理原子性、可见性、有序性来建立的，而我们保证一个变量在多线程中并发安全也是通过这三个原则保证的。
JMM内存模型
+ 原子性：通过原子操作保证，基本数据类型都是具备原子性的，long和double有个非原子性协定，即8字节的double和long可拆成两次4字节操作，不过大部分实现都是原子性的
更大的原子性可以通过monitor指令，即synchronized关键字
+ 可见性：通过volatile变量，或者synchronized关键字，或者final不可变量
+ 有序性：通过volatile变量，或者synchronized加锁

##### 先行发生原则（happens-before）
首先需要知道先行发生原则是用来干嘛的？
> 它是用来判断数据是否存在竞争、线程是否安全的主要依据
> 通过它可以判断线程操作是否安全
如果操作A先行发生于操作B，那么发生操作B之前，操作A的影响能够被B观察到，包括修改内存值，发送消息、调用方法等。
```language
程序次序（一个线程内在前面的先行于后面的）、
管程锁定（unlock操作先于lock，同一个锁必须在解锁之后才能加锁）、
volatile变量、
线程启动（start方法先于线程run动作）、
线程终止（线程所有操作都先于对线程终止检测，即一旦检测到终止，说明run方法执行完了）、
线程中断（对interrupt（）的调用先于被中断线程代码检测到中断事件发生）、
对象终结（对象构造方法先于finalize方法）、
传递性（操作A先于B，B先于C，则A一定先于C）
```

