---
title: JVM（三）内存分配和垃圾回收
date: 2018-04-24 23:50:59
tags: [JVM]
---
#### 垃圾回收
##### 概述
JVM中，程序计数器、虚拟机栈、本地方法栈都是随线程而生而灭，栈帧随方法进入和退出进行入栈出栈，自动进行内存清理，我们回收的主要区域在于方法区和堆，这部分内存是程序员运行期间动态分配的。
##### 对象存活判断
1. 引用计数算法
每个对象有个引用计数器，一个地方引用它就加一，当引用失效就减一，当计数为0时，就可以回收。
无法解决循环引用问题

2. 可达性分析
从一系列被称作GC Root的对象作为起始点，向下搜索的路径称为引用链。当一个对象没有和任何引用链相连时，证明对象不可达。
GC Roots对象：
+ 虚拟机栈引用的对象
+ 方法区类静态属性引用的对象
+ 方法区常量引用的对象
+ 本地方法栈引用的对象

###### 二次标记
当一个对象被标记为不可达时，至少经历两次标记过程：一次是可达性分析发现没有和GC Roots链相连，这时候会第一次标记并进行筛选，是否有必要执行finalize方法，如果没有覆盖过finalize方法或者已经被执行过，这两种情况被视为“没有必要执行finalize方法”，会被回收
如果被判定有必要执行finalize方法后，会将这个对象放到一个队列中，虚拟机自动执行finalize方法，如果这时候对象被引用到GC Roots链了，就不会被回收，如果没有，就会被回收，但注意这个队列是优先级很低的，不会保证一定会执行完成。

##### 回收算法
1. 标记-清除
对象被标记，首先标记出所有需要回收的对象，然后统一回收清除。
缺点：一、效率问题，标记和清除的效率都不高；二、空间问题，产生大量不连续内存碎片

2. 复制算法
将内存分成大小相同的两块，每次只使用其中一块，当内存不够时，将存活的对象都复制到另一块内存，然后清空本块内存。
缺点：内存使用率低；对象存活率高的时候，复制操作效率低

3. 标记-整理
采用“标记-清除”算法之后，将存活对象移动到一边，然后清除边界外的内存

**分代收集算法**
GC假设：绝大部分对象的生命周期都十分短暂，存活时间短。
将Java堆分为两块，新生代和老年代，根据各个年代特点选择回收算法。新生代分为一块较大的Eden区和两块较小的Survivor区，每次使用其中的Eden区和一块Survivor区，当回收时，将存活的对象复制到另一块Survivor区，然后清空Eden区和之前的Survivor区，然后再使用这一次的Survivor区和Eden区，默认比例是Eden：S1：S2 = 8：1：1.但当复制的时候发现Survivor区不够用，就需要内存进行担保，这时候就需要老年代的内存，进行分配担保（Handler Promotion）
新生代采用复制算法，老年代因为对象存活时间长，采用标记-清理或标记-整理

##### 内存分配与回收策略
JVM内存管理的主要问题是：给对象分配内存和回收分配给对象的内存
1. 对象优先分配在Eden区
当Eden区没有足够的内存时，会发生一次MinorGC，就是进行“复制算法”，清理Eden和使用的Survivor，复制到另一个Survivor

2. 大对象直接进入老年代
大对象是指：需要大量连续内存空间的Java对象，例如字符串以及数组

3. 长期存活的对象进入老年代
每个对象会有一个Age计数器，没经过一次MinorGC就会加1，当Age增长到一定时，就会进入老年代

4. 动态判定年龄
当Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于这个值的就可以进入老年代

5. 空间分配担保
这个就是当MinorGC之前说的分配担保。当需要发生MinorGC时，JVM先检查老年代最大可用连续内存空间是否大于新生代所有对象总空间，如果大于则说明可以进行MinorGC，即安全的；如果不大于，就会查看HandlePromotionFailure是否允许担保失败，如果不允许，就进行FullGC；如果允许，就查看老年代的最大可用连续空间大于历次晋升老年代对象平均大小，如果大于，就会尝试一次MinorGC，尽管是有风险的；如果小于，不能冒险，进行FullGC。
“冒险”：时间成本。如果冒险进行了MinorGC，后来发现担保失败，自己内存不够，需要FullGC，就会浪费这次的担保需要的时间

MinorGC发生在新生代，FullGC发生在老年代，而且会进行一次StopTheWorld，消耗很大


#### 垃圾收集器
	垃圾收集器是内存回收算法的具体实现

1. Serial收集器
单线程回收，垃圾回收时会StopTheWorld,适用于Client端
![](serial.jpg)
ParNew收集器，多线程版Serial，适用于服务端
![](parnew.jpg)

2. CMS收集器
主要回收目标在于最短回收时间，并发收集，低停顿，但产生大量碎片
![](cms.jpg)

3. G1收集器


